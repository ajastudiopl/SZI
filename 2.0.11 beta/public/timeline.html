<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <title>Timeline Show</title>
    <style>
        /* Stylizacja */
        body {
            font-family: Arial, sans-serif;
            background-color: #f0f0f0;
            padding: 20px;
        }

        /* Stylowanie Waveform */
        #waveform {
            width: 100%;
            height: 200px;
            background-color: #eaeaea;
            border-radius: 8px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
            margin-bottom: 10px;
            position: relative;
        }

        .cue-marker {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 2px;
            background-color: red;
            cursor: pointer;
        }

        .cue-label {
            position: absolute;
            top: -20px;
            transform: translateX(-50%);
            font-size: 12px;
            color: black;
            white-space: nowrap;
        }

        /* Stylowanie Skali Czasu */
        #timeScale {
            width: 100%;
            position: relative;
            height: 20px;
            margin-top: 10px;
        }

        #timeScale .time-tick {
            position: absolute;
            top: 0;
            transform: translateX(-50%);
            font-size: 12px;
            color: #555;
            font-weight: bold;
        }

        /* Stylowanie Przycisków i Inputów */
        button, input[type="file"], #cueList, #sceneList {
            margin-top: 20px;
        }

        button {
            padding: 10px 20px;
            background-color: #4F4A85;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            margin-right: 10px;
        }

        button:hover {
            background-color: #383351;
        }

        input[type="file"] {
            display: none;
        }

        .file-input-label {
            padding: 10px 20px;
            background-color: #4F4A85;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            display: inline-block;
            text-align: center;
        }

        .file-input-label:hover {
            background-color: #383351;
        }

        /* Stylowanie Listy Cue i Scen */
        #cueList, #sceneList {
            list-style-type: none;
            padding: 0;
        }

        #cueList li, #sceneList li {
            background-color: #fff;
            padding: 10px;
            margin-bottom: 5px;
            border: 1px solid #ccc;
            border-radius: 5px;
        }

        #sceneList li {
            cursor: pointer;
        }

        #sceneList li.selected {
            background-color: #4F4A85;
            color: white;
        }

        #sceneList li .cue-list {
            margin-top: 10px;
            display: none;
        }

        #sceneList li.expanded .cue-list {
            display: block;
        }

        /* Stylowanie Timera */
        #timer {
            font-size: 24px;
            font-weight: bold;
            margin-bottom: 20px;
            text-align: center;
        }

        /* Stylowanie Modala */
        .modal {
            display: none; /* Ukryty domyślnie */
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.5);
        }

        .modal-content {
            background-color: #fefefe;
            margin: 5% auto;
            padding: 20px;
            border: 1px solid #888;
            width: 400px;
            border-radius: 8px;
            position: relative;
        }

        .close-modal {
            color: #aaa;
            float: right;
            font-size: 24px;
            font-weight: bold;
            cursor: pointer;
            position: absolute;
            top: 10px;
            right: 20px;
        }

        .close-modal:hover,
        .close-modal:focus {
            color: black;
            text-decoration: none;
        }

        /* Dodatkowe Style */
        .user-content-editor select, .user-content-editor textarea {
            width: 100%;
            margin-bottom: 10px;
        }

        .time-input {
            width: 80px;
        }

        /* Responsywny Modal */
        @media (max-width: 500px) {
            .modal-content {
                width: 90%;
            }
        }

        /* Podświetlanie Cue */
        .highlight {
            background-color: yellow;
            transition: background-color 0.5s;
        }

        /* Stylowanie przycisków w liście scen */
        #sceneList button {
            background-color: #c0392b;
            padding: 5px 10px;
            font-size: 12px;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            color: white;
        }

        #sceneList button:hover {
            background-color: #e74c3c;
        }

        /* Stylowanie przycisku "Dodaj do listy scen" */
        #sceneList .add-to-scene-list-btn {
            background-color: #27ae60;
        }

        #sceneList .add-to-scene-list-btn:hover {
            background-color: #1e8449;
        }

        /* Stylowanie przycisków Start i Stop */
        #startTimelineBtn {
            background-color: #28a745;
        }

        #startTimelineBtn:hover {
            background-color: #218838;
        }

        #stopTimelineBtn {
            background-color: red;
        }

        #stopTimelineBtn:hover {
            background-color: darkred;
        }

        /* Kontener przycisków na górze */
        .button-container {
            display: flex;
            justify-content: space-between;
            align-items: center;
            position: fixed;
            top: 0;
            width: 100%;
            padding: 10px;
            background-color: white;
            box-shadow: 0px 4px 6px rgba(0, 0, 0, 0.1);
            z-index: 1000;
        }

        .button-container button {
            margin-right: 0;
        }

        /* Dostosowanie marginesu dla zawartości poniżej */
        .content {
            margin-top: 80px; /* Aby nie nachodzić na przyciski */
        }
    </style>
</head>
<body>

<!-- Kontenery przycisków na górze -->
<div class="button-container">
    <!-- Przycisk powrotu do trybu edycji -->
    <button id="backToEditBtn">Powrót do trybu edycji</button>
    <!-- Przycisk Start -->
    <button id="startTimelineBtn">Start</button>
    <!-- Przycisk Stop -->
    <button id="stopTimelineBtn">Stop</button>
</div>

<div class="content">
    <!-- Timer pokazujący aktualny czas na osi czasu -->
    <div id="timer">00:00:00</div>

    <!-- Kontener Waveform -->
    <div id="waveform"></div>

    <!-- Skala Czasu -->
    <div id="timeScale">
        <!-- Znaczniki czasu zostaną wygenerowane dynamicznie -->
    </div>

    <!-- Kontrolki -->
    <div>
        <!-- Input do wczytywania pliku audio -->
        <label for="fileInput" class="file-input-label">Wybierz plik audio</label>
        <input type="file" id="fileInput" accept="audio/*" />

        <!-- Przycisk dodawania Cue -->
        <button id="addCueBtn">Dodaj Cue w aktualnym czasie</button>

        <!-- Przycisk dodawania Sceny -->
        <button id="addSceneBtn">Dodaj Scenę</button>

        <!-- Przycisk zapisywania Scen -->
        <button id="saveScenesBtn">Zapisz Sceny</button>
    </div>

    <!-- Lista Scen -->
    <h3>Sceny</h3>
    <ul id="sceneList">
        <!-- Sceny zostaną dodane dynamicznie -->
    </ul>
</div>

<!-- Modal do edycji Cue -->
<div id="editCueModal" class="modal">
    <div class="modal-content">
        <span class="close-modal" id="closeEditCueModalBtn">&times;</span>
        <h2>Edytuj Cue</h2>
        <div>
            <label for="cue-name-input">Nazwa Cue:</label>
            <input type="text" id="cue-name-input">
        </div>
        <div>
            <label for="cue-time-input">Czas Cue (mm:ss:ms):</label>
            <input type="text" id="cue-time-input">
        </div>
        <div>
            <label for="cue-users">Wybierz Użytkowników:</label>
            <select id="cue-users" multiple>
                <!-- Opcje użytkowników zostaną dodane dynamicznie -->
            </select>
        </div>
        <div id="cue-messages">
            <!-- Pola wiadomości dla wybranych użytkowników -->
        </div>
        <div id="cue-urls">
            <!-- Pola URL dla wybranych użytkowników -->
        </div>
        <div style="display: flex; justify-content: space-between; margin-top: 20px;">
            <div>
                <button id="previousCueBtn">Poprzednie Cue</button>
                <button id="nextCueBtn">Następne Cue</button>
            </div>
            <div>
                <button id="saveCueEditsBtn">Zapisz</button>
            </div>
        </div>
    </div>
</div>

<script type="module">
    import WaveSurfer from 'https://cdn.jsdelivr.net/npm/wavesurfer.js@7/dist/wavesurfer.esm.js';

    // Inicjalizacja zmiennych
    let wavesurfer = null;
    let scenes = [];
    let currentScene = null;
    let users = []; // Lista użytkowników
    let websocket = null;
    let editingCueId = null;
    let cueCount = 0; // Numeracja Cue w aktualnej scenie
    let isPlaying = false; // Flaga informująca, czy odtwarzanie jest w toku
    let serverIP = 'localhost'; // Domyślny adres IP serwera

    // Elementy DOM
    const backToEditBtn = document.getElementById('backToEditBtn');
    const startTimelineBtn = document.getElementById('startTimelineBtn');
    const stopTimelineBtn = document.getElementById('stopTimelineBtn');
    const fileInput = document.getElementById('fileInput');
    const addCueBtn = document.getElementById('addCueBtn');
    const addSceneBtn = document.getElementById('addSceneBtn');
    const sceneList = document.getElementById('sceneList');
    const saveScenesBtn = document.getElementById('saveScenesBtn');
    const timer = document.getElementById('timer');

    // Elementy Modala
    const editCueModal = document.getElementById('editCueModal');
    const cueNameInput = document.getElementById('cue-name-input');
    const cueTimeInput = document.getElementById('cue-time-input');
    const cueUsersSelect = document.getElementById('cue-users');
    const cueMessagesDiv = document.getElementById('cue-messages');
    const cueUrlsDiv = document.getElementById('cue-urls');
    const closeEditCueModalBtn = document.getElementById('closeEditCueModalBtn');
    const previousCueBtn = document.getElementById('previousCueBtn');
    const nextCueBtn = document.getElementById('nextCueBtn');
    const saveCueEditsBtn = document.getElementById('saveCueEditsBtn');

    // Dodanie nasłuchiwaczy zdarzeń dla przycisków w Modalu
    closeEditCueModalBtn.addEventListener('click', closeEditCueModal);
    previousCueBtn.addEventListener('click', previousCue);
    nextCueBtn.addEventListener('click', nextCue);
    saveCueEditsBtn.addEventListener('click', saveCueEdits);

    // Przypisz nasłuchiwacz zdarzeń dla cueUsersSelect
    cueUsersSelect.addEventListener('change', () => {
        if (!editingCueId || !currentScene) return;
        const selectedUsers = Array.from(cueUsersSelect.selectedOptions).map(option => option.value);
        const cue = currentScene.cues.find(c => c.id === editingCueId);
        if (!cue) return;
        cue.users = selectedUsers;
        generateCueMessageInputs(selectedUsers, cue.messages, cue.urls);
    });

    // Inicjalizacja
    window.addEventListener('load', () => {
        loadConfig().then(() => {
            initWebSocket();
            fetchUsers();
            loadScenesFromServer();
        });
    });

    // Funkcja do pobrania konfiguracji serwera
    async function loadConfig() {
        try {
            const response = await fetch('/config');
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            const data = await response.json();
            serverIP = data.serverIP || 'localhost';
            console.log('Adres IP serwera:', serverIP);
        } catch (error) {
            console.error('Błąd podczas pobierania konfiguracji:', error);
            alert('Nie udało się pobrać konfiguracji serwera. Upewnij się, że serwer jest uruchomiony.');
        }
    }

    // Funkcje WebSocket
    function initWebSocket() {
        websocket = new WebSocket(`ws://${serverIP}:8080`);

        websocket.onopen = function () {
            console.log('Połączenie WebSocket otwarte');
        };

        websocket.onmessage = function (event) {
            console.log('Otrzymano wiadomość:', event.data);
        };

        websocket.onclose = function () {
            console.log('Połączenie WebSocket zamknięte');
        };

        websocket.onerror = function (error) {
            console.error('Błąd WebSocket:', error);
        };
    }

    // Pobieranie Użytkowników z serwera
    function fetchUsers() {
        fetch('/users')
            .then(response => response.json())
            .then(data => {
                if (data.users && Array.isArray(data.users)) {
                    users = data.users;
                    initializeUserOptions();
                }
            })
            .catch(error => {
                console.error('Błąd podczas pobierania użytkowników:', error);
            });
    }

    // Inicjalizacja opcji Użytkowników w Modalu
    function initializeUserOptions() {
        cueUsersSelect.innerHTML = '';
        users.forEach(user => {
            const option = document.createElement('option');
            option.value = user.id;
            option.textContent = user.name;
            cueUsersSelect.appendChild(option);
        });
    }

    // Funkcja do tworzenia bezpiecznych ID
    function makeSafeId(id) {
        return String(id).replace(/[^a-zA-Z0-9_-]/g, '_');
    }

    // Inicjalizacja WaveSurfer
    function initializeWaveSurfer() {
        if (wavesurfer) {
            wavesurfer.destroy();
        }
        wavesurfer = WaveSurfer.create({
            container: '#waveform',
            waveColor: '#4F4A85',
            progressColor: '#383351',
            height: 150,
        });

        // Aktualizuj timer w trakcie odtwarzania
        wavesurfer.on('audioprocess', () => {
            const currentTime = wavesurfer.getCurrentTime();
            timer.textContent = formatTimeWithMillis(currentTime);

            // Aktualizuj currentTime w currentScene
            if (currentScene) {
                currentScene.currentTime = currentTime;
            }

            if (currentScene && currentScene.cues) {
                currentScene.cues.forEach(cue => {
                    if (!cue.triggered && currentTime >= cue.time) {
                        cue.triggered = true;
                        triggerCue(cue);
                    }
                });
            }
        });

        // Aktualizuj timer po kliknięciu na waveform
        wavesurfer.on('seek', () => {
            const currentTime = wavesurfer.getCurrentTime();
            timer.textContent = formatTimeWithMillis(currentTime);

            // Aktualizuj currentTime w currentScene
            if (currentScene) {
                currentScene.currentTime = currentTime;
            }
        });

        // Dodaj skalę czasu po załadowaniu audio
        wavesurfer.on('ready', () => {
            addTimeScale();
            renderCuesOnWaveform();

            // Zapisz długość utworu
            if (currentScene) {
                currentScene.duration = wavesurfer.getDuration();
            }
        });
    }

    // Funkcje kontrolne
    startTimelineBtn.addEventListener('click', startTimeline);
    stopTimelineBtn.addEventListener('click', stopTimeline);
    backToEditBtn.addEventListener('click', goBackToEdit);
    fileInput.addEventListener('change', handleFileUpload);
    addCueBtn.addEventListener('click', addCueAtCurrentTime);
    addSceneBtn.addEventListener('click', createScene);
    saveScenesBtn.addEventListener('click', saveScenesToServer);

    document.addEventListener('keydown', (event) => {
        if (event.code === 'Space') {
            const activeElement = document.activeElement;
            if (activeElement.tagName !== 'INPUT' && activeElement.tagName !== 'TEXTAREA' && activeElement.tagName !== 'SELECT') {
                event.preventDefault();
                if (isPlaying) {
                    stopTimeline();
                } else {
                    startTimeline();
                }
            }
        }
    });

    function startTimeline() {
        if (isPlaying) return;
        if (wavesurfer) {
            wavesurfer.play();
            isPlaying = true;
            startTimelineBtn.disabled = true;
            stopTimelineBtn.disabled = false;
        } else {
            alert('Proszę załadować plik audio przed rozpoczęciem odtwarzania.');
        }
    }

    function stopTimeline() {
        if (!isPlaying) return;
        if (wavesurfer) {
            wavesurfer.pause();
            isPlaying = false;
            startTimelineBtn.disabled = false;
            stopTimelineBtn.disabled = true;

            // Resetuj trigger dla wszystkich Cue
            if (currentScene && currentScene.cues) {
                currentScene.cues.forEach(cue => {
                    cue.triggered = false;
                });
            }

            // Wysłanie wiadomości resetującej do użytkowników
            resetUsers();
        }
    }

    function resetUsers() {
        if (websocket && websocket.readyState === WebSocket.OPEN) {
            const resetMessage = {
                type: 'reset',
                instruction: '',
                url: ''
            };
            websocket.send(JSON.stringify(resetMessage));
            console.log('Wysłano wiadomość resetującą do użytkowników.');
        }
    }

    function goBackToEdit() {
        window.location.href = 'editmode.html';
    }

    function handleFileUpload(event) {
        const file = event.target.files[0];
        if (file && currentScene) {
            const formData = new FormData();
            formData.append('audio', file);

            fetch('/upload-audio', {
                method: 'POST',
                body: formData
            })
            .then(response => response.json())
            .then(data => {
                if (data.audioURL) {
                    currentScene.audioURL = data.audioURL;
                    initializeWaveSurfer();
                    wavesurfer.load(currentScene.audioURL);

                    // Zapisz sceny na serwerze po otrzymaniu audioURL
                    saveScenesToServer();
                } else {
                    alert('Błąd podczas przesyłania pliku audio.');
                }
            })
            .catch(error => {
                console.error('Błąd podczas przesyłania pliku audio:', error);
                alert('Nie udało się przesłać pliku audio na serwer.');
            });

            currentScene.audioFileName = file.name;
        } else {
            alert('Proszę wybrać lub utworzyć scenę przed przesłaniem pliku audio.');
        }
    }

    // Funkcje związane z czasem
    function formatTimeWithMillis(time) {
        const minutes = Math.floor(time / 60);
        const seconds = Math.floor(time % 60);
        const millis = Math.floor((time % 1) * 100);
        return `${minutes < 10 ? '0' + minutes : minutes}:${seconds < 10 ? '0' + seconds : seconds}:${millis < 10 ? '0' + millis : millis}`;
    }

    function parseTime(timeStr) {
        const [minutes, seconds, millis] = timeStr.split(':').map(Number);
        return (minutes * 60) + seconds + ((millis || 0) / 100);
    }

    // Funkcje Zarządzania Scenami
    function createScene() {
        const sceneId = `scene-${uuidv4()}`;
        const newScene = {
            id: sceneId,
            type: 'timeline',
            title: `Scena ${scenes.length + 1}`,
            description: '',
            audioURL: null,
            audioFileName: '',
            cues: [],
            cueCount: 0,
            duration: 0,
            currentTime: 0
        };
        scenes.push(newScene);
        currentScene = newScene;
        cueCount = 0;
        renderScenes();
        initializeWaveSurfer();
    }

    function renderScenes() {
        sceneList.innerHTML = '';
        scenes.forEach(scene => {
            const listItem = document.createElement('li');
            listItem.textContent = scene.title;
            listItem.setAttribute('data-id', scene.id);

            const toggleCuesBtn = document.createElement('button');
            toggleCuesBtn.textContent = '+';
            toggleCuesBtn.style.marginLeft = '10px';
            toggleCuesBtn.addEventListener('click', (event) => {
                event.stopPropagation();
                listItem.classList.toggle('expanded');
            });

            listItem.prepend(toggleCuesBtn);

            listItem.addEventListener('click', () => {
                selectScene(scene.id);
            });

            // Przycisk usuwania sceny
            const deleteBtn = document.createElement('button');
            deleteBtn.textContent = 'Usuń';
            deleteBtn.style.backgroundColor = '#e74c3c';
            deleteBtn.style.marginLeft = '10px';
            deleteBtn.style.cursor = 'pointer';
            deleteBtn.addEventListener('click', (event) => {
                event.stopPropagation();
                deleteScene(scene.id);
            });

            // Przycisk dodania sceny do listy scen w editmode
            const addToSceneListBtn = document.createElement('button');
            addToSceneListBtn.textContent = 'Dodaj do listy scen';
            addToSceneListBtn.classList.add('add-to-scene-list-btn');
            addToSceneListBtn.addEventListener('click', (event) => {
                event.stopPropagation();
                addSceneToEditMode(scene);
            });

            listItem.appendChild(deleteBtn);
            listItem.appendChild(addToSceneListBtn);

            if (currentScene && scene.id === currentScene.id) {
                listItem.classList.add('selected');
            } else {
                listItem.classList.remove('selected');
            }

            // Lista Cue w scenie
            const cueListElement = document.createElement('ul');
            cueListElement.classList.add('cue-list');
            scene.cues.forEach((cue, index) => {
                const cueItem = document.createElement('li');

                // Element z nazwą cue i czasem
                const cueInfo = document.createElement('span');
                cueInfo.textContent = `${cue.name} (${formatTimeWithMillis(cue.time)})`;
                cueInfo.style.cursor = 'pointer';
                cueInfo.addEventListener('click', (event) => {
                    event.stopPropagation();
                    openEditCueModal(cue.id);
                });

                cueItem.appendChild(cueInfo);

                // Przycisk "Aktualizuj Czas"
                const updateTimeBtn = document.createElement('button');
                updateTimeBtn.textContent = 'Aktualizuj Czas';
                updateTimeBtn.style.marginLeft = '10px';
                updateTimeBtn.addEventListener('click', (event) => {
                    event.stopPropagation();
                    updateCueTimeToCurrent(cue.id);
                });
                cueItem.appendChild(updateTimeBtn);

                cueListElement.appendChild(cueItem);
            });

            listItem.appendChild(cueListElement);
            sceneList.appendChild(listItem);
        });
    }

    function selectScene(sceneId) {
        currentScene = scenes.find(scene => scene.id === sceneId);
        renderScenes();
        if (currentScene.audioURL) {
            initializeWaveSurfer();
            wavesurfer.load(currentScene.audioURL);
        } else {
            initializeWaveSurfer();
        }
        renderCuesOnWaveform();
        cueCount = currentScene.cues.length;
    }

    function deleteScene(sceneId) {
        if (confirm('Czy na pewno chcesz usunąć tę scenę?')) {
            scenes = scenes.filter(scene => scene.id !== sceneId);
            if (currentScene && currentScene.id === sceneId) {
                currentScene = scenes.length > 0 ? scenes[0] : null;
            }
            renderScenes();
            if (currentScene) {
                selectScene(currentScene.id);
            } else {
                initializeWaveSurfer();
            }
        }
    }

    function addSceneToEditMode(scene) {
        const sceneCopy = { ...scene, type: 'regular' };
        fetch(`/add-scene`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(sceneCopy)
        })
        .then(response => response.json())
        .then(data => {
            alert('Scena została dodana do listy scen w editmode.');
        })
        .catch(error => {
            console.error('Błąd podczas dodawania sceny do editmode:', error);
            alert('Nie udało się dodać sceny do listy scen.');
        });
    }

    // Funkcje Zarządzania Cue
    function addCueAtCurrentTime() {
        if (!currentScene) {
            alert('Proszę wybrać lub utworzyć scenę przed dodaniem Cue.');
            return;
        }
        if (wavesurfer) {
            const currentTime = wavesurfer.getCurrentTime();
            addCue(currentTime);
        } else {
            alert('Proszę załadować plik audio lub zainicjalizować oś czasu.');
        }
    }

    function addCue(time) {
        cueCount++;
        const cueId = `cue-${uuidv4()}`;

        // Dodaj Cue do aktualnej sceny
        const cueData = {
            id: cueId,
            name: `Cue ${cueCount}`,
            time: time,
            users: [],
            messages: {},
            urls: {},
            triggered: false,
            sceneId: currentScene.id
        };
        currentScene.cues.push(cueData);

        renderScenes();
        renderCuesOnWaveform();
    }

    function updateCueTimeToCurrent(cueId) {
        if (!wavesurfer) return;
        const currentTime = wavesurfer.getCurrentTime();
        const cue = currentScene.cues.find(c => c.id === cueId);
        if (!cue) return;

        cue.time = currentTime;
        cue.triggered = false;

        // Update the marker position
        const marker = document.querySelector(`.cue-marker[data-id="${cueId}"]`);
        if (marker) {
            marker.style.left = `${(currentTime / wavesurfer.getDuration()) * 100}%`;
            marker.setAttribute('data-time', currentTime);
        }

        // Update the cue display in the list
        renderScenes();

        // Save changes to the server
        saveScenesToServer();
    }

    function renderCuesOnWaveform() {
        // Usuń istniejące markery
        document.querySelectorAll('.cue-marker').forEach(marker => marker.remove());

        if (!currentScene || !wavesurfer) return;

        currentScene.cues.forEach(cue => {
            const time = cue.time;
            const name = cue.name;
            const cueId = cue.id;

            // Dodaj marker do waveform
            const marker = document.createElement('div');
            marker.classList.add('cue-marker');
            marker.style.left = `${(time / wavesurfer.getDuration()) * 100}%`;
            marker.setAttribute('data-time', time);
            marker.setAttribute('data-id', cueId);

            // Dodaj etykietę nazwy Cue
            const label = document.createElement('div');
            label.classList.add('cue-label');
            label.textContent = name;
            marker.appendChild(label);

            marker.addEventListener('click', () => {
                openEditCueModal(cueId);
            });

            document.getElementById('waveform').appendChild(marker);
        });
    }

    // Funkcje Modala do Edycji Cue
    function openEditCueModal(cueId) {
        editingCueId = cueId;
        const cue = currentScene.cues.find(c => c.id === cueId);
        if (!cue) return;

        // Upewnij się, że messages, urls i users są zainicjalizowane
        cue.messages = cue.messages || {};
        cue.urls = cue.urls || {};
        cue.users = cue.users || [];

        // Wypełnij pola nazwy i czasu Cue
        cueNameInput.value = cue.name || '';
        cueTimeInput.value = formatTimeWithMillis(cue.time);

        // Wypełnij listę użytkowników
        Array.from(cueUsersSelect.options).forEach(option => {
            option.selected = cue.users.includes(option.value);
        });

        // Generuj pola wiadomości i URL dla wybranych użytkowników
        generateCueMessageInputs(cue.users, cue.messages, cue.urls);

        // Pokaż modal
        editCueModal.style.display = 'block';
    }

    function closeEditCueModal() {
        editCueModal.style.display = 'none';
        editingCueId = null;
    }

    function generateCueMessageInputs(selectedUsers, existingMessages, existingUrls) {
        cueMessagesDiv.innerHTML = '';
        cueUrlsDiv.innerHTML = '';
        existingMessages = existingMessages || {};
        existingUrls = existingUrls || {};
        selectedUsers.forEach(user => {
            const userName = users.find(u => u.id === user)?.name || user;
            const safeUserId = makeSafeId(user);

            const messageDiv = document.createElement('div');
            messageDiv.innerHTML = `
                <label for="message-${safeUserId}">Wiadomość dla ${userName}:</label>
                <textarea id="message-${safeUserId}" data-user="${user}" rows="2">${existingMessages[user] || ''}</textarea>
            `;
            cueMessagesDiv.appendChild(messageDiv);

            const urlDiv = document.createElement('div');
            urlDiv.innerHTML = `
                <label for="url-${safeUserId}">URL dla ${userName}:</label>
                <input type="text" id="url-${safeUserId}" data-user="${user}" value="${existingUrls[user] || ''}">
            `;
            cueUrlsDiv.appendChild(urlDiv);
        });
    }

    function saveCueEdits() {
        try {
            if (!editingCueId || !currentScene) return;
            const cue = currentScene.cues.find(c => c.id === editingCueId);
            if (!cue) return;

            // Aktualizuj nazwę i czas Cue
            cue.name = cueNameInput.value;
            cue.time = parseTime(cueTimeInput.value);
            cue.triggered = false;

            // Aktualizuj użytkowników
            const selectedUsers = Array.from(cueUsersSelect.selectedOptions).map(option => option.value);
            cue.users = selectedUsers;

            // Aktualizuj wiadomości i URL
            cue.messages = {};
            cue.urls = {};

            selectedUsers.forEach(user => {
                const safeUserId = makeSafeId(user);

                const messageTextarea = document.getElementById(`message-${safeUserId}`);
                if (messageTextarea) {
                    cue.messages[user] = messageTextarea.value;
                }

                const urlInput = document.getElementById(`url-${safeUserId}`);
                if (urlInput) {
                    cue.urls[user] = urlInput.value;
                }
            });

            // Dodaj logowanie, aby sprawdzić, czy dane są poprawnie ustawione
            console.log('Zapisane dane Cue:', cue);

            // Zamknij modal
            closeEditCueModal();

            // Zapisz sceny na serwerze
            saveScenesToServer();

            renderScenes();
            renderCuesOnWaveform();
        } catch (error) {
            console.error('Błąd podczas zapisywania edycji Cue:', error);
            alert('Wystąpił błąd podczas zapisywania edycji Cue. Sprawdź konsolę przeglądarki.');
        }
    }

    function previousCue() {
        if (!editingCueId || !currentScene) return;
        const cues = currentScene.cues;
        const index = cues.findIndex(c => c.id === editingCueId);
        if (index > 0) {
            saveCueEdits(); // Zapisz zmiany przed przejściem
            openEditCueModal(cues[index - 1].id);
        }
    }

    function nextCue() {
        if (!editingCueId || !currentScene) return;
        const cues = currentScene.cues;
        const index = cues.findIndex(c => c.id === editingCueId);
        if (index < cues.length - 1) {
            saveCueEdits(); // Zapisz zmiany przed przejściem
            openEditCueModal(cues[index + 1].id);
        }
    }

    // Funkcja do wyzwalania Cue
    function triggerCue(cue) {
        if (websocket && websocket.readyState === WebSocket.OPEN) {
            cue.users.forEach(user => {
                const message = {
                    type: 'user-instruction',
                    userId: user,
                    instruction: cue.messages[user] || '',
                    url: cue.urls[user] || '',
                    sceneId: cue.sceneId,
                    cueId: cue.id,
                    cueTime: cue.time
                };
                websocket.send(JSON.stringify(message));
                console.log('Wysłano wiadomość do użytkownika:', user, message);
            });
        } else {
            console.error('WebSocket nie jest otwarty');
        }
    }

    // Funkcje Zapisywania i Ładowania Scen z Serwera
    function saveScenesToServer() {
        // Przygotuj dane scen do zapisu
        const scenesToSave = scenes.map(scene => {
            const sceneCopy = { ...scene };
            // Usuwamy audioData, jeśli istnieje
            delete sceneCopy.audioData;
            return sceneCopy;
        });

        fetch(`/save-scenes`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ scenes: scenesToSave.filter(scene => scene.type === 'timeline') })
        })
        .then(response => {
            if (!response.ok) {
                return response.json().then(errorData => {
                    throw new Error(errorData.error || 'Błąd podczas zapisywania scen.');
                });
            }
            return response.json();
        })
        .then(data => {
            console.log('Sceny zapisane na serwerze.');
        })
        .catch(error => {
            console.error('Błąd podczas zapisywania scen:', error);
            alert('Nie udało się zapisać scen. Sprawdź połączenie z serwerem.');
        });
    }

    function loadScenesFromServer() {
        fetch(`/scenes?type=timeline`)
            .then(response => response.json())
            .then(data => {
                if (data.scenes && Array.isArray(data.scenes)) {
                    scenes = data.scenes.filter(scene => scene.type === 'timeline');

                    // Inicjalizacja messages i urls dla każdego Cue
                    scenes.forEach(scene => {
                        scene.cues.forEach(cue => {
                            cue.messages = cue.messages || {};
                            cue.urls = cue.urls || {};
                            cue.triggered = false; // Resetujemy flagę triggered
                        });
                    });

                    if (scenes.length > 0) {
                        currentScene = scenes[0];
                        selectScene(currentScene.id);
                    }
                    renderScenes();
                    console.log('Załadowane sceny z serwera:', scenes);
                }
            })
            .catch(error => {
                console.error('Błąd podczas ładowania scen:', error);
            });
    }

    // Funkcja dodająca skalę czasu
    function addTimeScale() {
        const timeScale = document.getElementById('timeScale');
        timeScale.innerHTML = '';
        const duration = wavesurfer.getDuration();
        if (!duration) return;
        const step = 10; // Co 10 sekund

        for (let i = 0; i <= duration; i += step) {
            const tick = document.createElement('span');
            tick.classList.add('time-tick');
            tick.style.left = `${(i / duration) * 100}%`;
            tick.textContent = `${Math.floor(i / 60)}:${i % 60 < 10 ? '0' + (i % 60) : i % 60}`;
            timeScale.appendChild(tick);
        }
    }

    // Generowanie UUID
    function uuidv4() {
        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
            const r = Math.random() * 16 | 0,
                  v = c == 'x' ? r : (r & 0x3 | 0x8);
            return v.toString(16);
        });
    }

    // Zamknięcie Modala po kliknięciu poza nim
    window.onclick = function(event) {
        if (event.target == editCueModal) {
            closeEditCueModal();
        }
    }
</script>

</body>
</html>
